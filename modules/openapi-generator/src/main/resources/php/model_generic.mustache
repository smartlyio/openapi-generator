class {{classname}} {{#parentSchema}}extends {{{parent}}} {{/parentSchema}}{{^parentSchema}}implements ModelInterface, ArrayAccess{{/parentSchema}}
{
    const DISCRIMINATOR = {{#discriminator}}'{{discriminatorName}}'{{/discriminator}}{{^discriminator}}null{{/discriminator}};

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = '{{name}}';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        {{#vars}}'{{name}}' => '{{{dataType}}}'{{#hasMore}},
        {{/hasMore}}{{/vars}}
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPIFormats = [
        {{#vars}}'{{name}}' => {{#dataFormat}}'{{{dataFormat}}}'{{/dataFormat}}{{^dataFormat}}null{{/dataFormat}}{{#hasMore}},
        {{/hasMore}}{{/vars}}
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes{{#parentSchema}} + parent::openAPITypes(){{/parentSchema}};
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats{{#parentSchema}} + parent::openAPIFormats(){{/parentSchema}};
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        {{#vars}}'{{name}}' => '{{baseName}}'{{#hasMore}},
        {{/hasMore}}{{/vars}}
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        {{#vars}}'{{name}}' => '{{setter}}'{{#hasMore}},
        {{/hasMore}}{{/vars}}
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        {{#vars}}'{{name}}' => '{{getter}}'{{#hasMore}},
        {{/hasMore}}{{/vars}}
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return {{#parentSchema}}parent::attributeMap() + {{/parentSchema}}self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return {{#parentSchema}}parent::setters() + {{/parentSchema}}self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return {{#parentSchema}}parent::getters() + {{/parentSchema}}self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    {{#vars}}{{#isEnum}}{{#allowableValues}}{{#enumVars}}const {{enumName}}_{{{name}}} = {{{value}}};
    {{/enumVars}}{{/allowableValues}}{{/isEnum}}{{/vars}}

    {{#vars}}{{#isEnum}}
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function {{getter}}AllowableValues()
    {
        return [
            {{#allowableValues}}{{#enumVars}}self::{{enumName}}_{{{name}}},{{^-last}}
            {{/-last}}{{/enumVars}}{{/allowableValues}}
        ];
    }
    {{/isEnum}}{{/vars}}

    {{^parentSchema}}
    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];
    {{/parentSchema}}

    public function values() {
        return $this->container;
    }

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        {{#parentSchema}}
        parent::__construct($data);
        {{/parentSchema}}
        {{#vars}}
        if ($data && array_key_exists('{{name}}', $data)) {
            $this->container['{{name}}'] = $data['{{name}}'];
        }{{#defaultValue}} else {
            $this->container['{{name}}'] = {{{defaultValue}}};
        }{{/defaultValue}}
	{{/vars}}
        {{#discriminator}}

        // Initialize discriminator property with the model name.
        $this->container['{{discriminatorName}}'] = static::$openAPIModelName;
        {{/discriminator}}
    }

    public static function additionalPropertiesType() {
        return {{#additionalPropertiesType}}{{additionalPropertiesType}}{{/additionalPropertiesType}}{{^additionalPropertiesType}}null{{/additionalPropertiesType}};
    }

    public function additionalPropertiesSetter($key, $value) {
        $this->container[$key] = $value;
    }

    public function additionalPropertiesGetter($key) {
        return $this->container[$key];
    }

    public static function oneOf() {
        return [{{#oneOfTypes}}'{{.}}'{{^-last}}, {{/-last}}{{/oneOfTypes}}];
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties(string $type = '')
    {
        {{#parent}}
        $invalidProperties = parent::listInvalidProperties();
        {{/parent}}
        {{^parent}}
        $invalidProperties = [];
        {{/parent}}

        {{#vars}}
        $invalidProperties = array_merge($invalidProperties,
            array_map(function($error) { return  $error->path('{{name}}'); }, self::validate_{{name}}($this->container['{{name}}'])));
        {{/vars}}
        return $invalidProperties;
    }

    public static function oneOfTypes(string $type): array {
        if (substr($type, 0, strlen('oneOf[')) === 'oneOf[') {
            $inner = substr($type, strlen('oneOf['), -1);
            return array_map('trim', explode(',', $inner));
        }
        return [];
    }

    private static function arrayType(string $type): ?string {
        if (substr($type, -2) === '[]') {
           return substr($type, 0, -2);
        }
        return null;
    }

    private static function errorsOneOf(array $options, $data): array {
        $errors = [];
        $matches = [];
        foreach($options as $option) {
            $option_errors = self::errorsAs($option, $data);
            if (empty($option_errors)) {
                $matches[] = $option;
            } else {
                $errors = array_merge($errors, $option_errors);
            }
        }
        if (count($matches) > 1) {
            return [new ValidationError('more than one matching type for oneOf ' . implode(' | ', $matches))];
        }
        if (count($matches) < 1) {
            return $errors;
        }
        return [];
    }

    private static function errorsArray(string $type, $data): array {
        if (!is_array($data)) {
            return ['value is not an array'];
        }
        $errors = [];
        foreach($data as $ix => $element) {
            $element_errors = array_map(function($e) use ($ix) { return $e->path($ix); }, self::errorsAs($type, $element));
            $errors = array_merge($errors, $element_errors);
        }
        return $errors;
    }

    private static function errorsPlainType(string $type, $data): array {
        if (is_object($data)) {
            if ('\\' . get_class($data) !== $type) {
                return [new ValidationError('incorrect type' . get_class($data))];
            }
        }
        return [];
    }

    private static function modelInterfaceType(string $type) {
        if (substr($type, 0, 1) !== '\\') {
          return null;
        }
        try {
            $instance = new $type();
        } catch (\Exception $e) {
            return null;
        }
        if ($instance instanceof ModelInterface) {
            return $instance;
        }
        return null;
    }

    private static function errorsModelInterface(ModelInterface $model, $data) {
	if (is_object($data)) {
            $type = get_class($data);
        } else {
            $type = gettype($data);
        }
        if ($type === get_class($model)) {
            return $data->listInvalidProperties();
        }
        if (count($model::oneOf()) > 0) {
            return self::errorsOneOf($model::oneOf(), $data);
        }
        return [new ValidationError('incorrect type ' . $type)];
    }

    public static function errorsAs(string $dataType, $data): array {
        if (self::oneOfTypes($dataType)) {
            return self::errorsOneOf(self::oneOfTypes($dataType), $data);
        }
        if (self::arrayType($dataType)) {
            return self::errorsArray(self::arrayType($dataType), $data);
        }
        if (self::modelInterfaceType($dataType)) {
            return self::errorsModelInterface(self::modelInterfaceType($dataType), $data);
        }
        return self::errorsPlainType($dataType, $data);
    }

    public static function dataType(): string {
        if (count(self::oneOf()) > 0) {
            return 'oneOf[' . implode(', ', self::oneOf()) . ']';
        }
        return '\\' . get_class();
    }

    public function validAs($dataType): bool {
        return count(self::errorsAs($dataType, $this)) === 0;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }

    {{#vars}}

    /**
     * Gets {{name}}
     *
     * @return {{dataType}}{{^required}}|null{{/required}}
     */
    public function {{getter}}()
    {
        return $this->container['{{name}}'];
    }

    /**
     * Sets {{name}}
     *
     * @param {{dataType}}{{^required}}|null{{/required}} ${{name}}{{#description}} {{{description}}}{{/description}}{{^description}} {{{name}}}{{/description}}
     *
     * @return $this
     */
    public function {{setter}}(${{name}}, bool $validate = true) {
        $errors = $validate ? $this->validate_{{name}}(${{name}}) : [];
        if (count($errors) > 0) {
            throw new \InvalidArgumentException(implode('\n', array_map(function($error) { return $error->path('{{name}}');}, $errors)));
        }
        $this->container['{{name}}'] = ${{name}};
        return $this;
    }

    public function validate_{{name}}(${{name}})
    {
        {{#isEnum}}
        $allowedValues = $this->{{getter}}AllowableValues();
        {{^isContainer}}
        if ({{^required}}!is_null(${{name}}) && {{/required}}!in_array(${{{name}}}, $allowedValues, true)) {
            return [new ValidationError(sprintf(
                "Invalid value for '{{name}}', must be one of '%s'",
                implode("', '", $allowedValues)
            ))];
        }
        {{/isContainer}}
        {{#isContainer}}
        if ({{^required}}!is_null(${{name}}) && {{/required}}array_diff(${{{name}}}, $allowedValues)) {
            return [new ValidationError(sprintf(
                    "Invalid value for '{{name}}', must be one of '%s'",
                    implode("', '", $allowedValues)
            ))];
        }
        {{/isContainer}}
        {{/isEnum}}
        {{#required}}
        if (${{name}} === null) {
            return [new ValidationError("can't be null")];
        }
        {{/required}}
        if (${{name}} !== null) {
            $errors = self::errorsAs('{{dataType}}', ${{name}});
            if (count($errors) > 0) {
                return  $errors;
            }
        }
        {{#hasValidation}}
        {{#maxLength}}
        if ({{^required}}!is_null(${{name}}) && {{/required}}(mb_strlen(${{name}}) > {{maxLength}})) {
            return [new ValidationError('invalid length for ${{name}} when calling {{classname}}.{{operationId}}, must be smaller than or equal to {{maxLength}}.')];
        }{{/maxLength}}
        {{#minLength}}
        if ({{^required}}!is_null(${{name}}) && {{/required}}(mb_strlen(${{name}}) < {{minLength}})) {
             return [new ValidationError('invalid length for ${{name}} when calling {{classname}}.{{operationId}}, must be bigger than or equal to {{minLength}}.')];
        }
        {{/minLength}}
        {{#maximum}}
        if ({{^required}}!is_null(${{name}}) && {{/required}}(${{name}} >{{#exclusiveMaximum}}={{/exclusiveMaximum}} {{maximum}})) {
            return [new ValidationError('invalid value for ${{name}} when calling {{classname}}.{{operationId}}, must be smaller than {{^exclusiveMaximum}}or equal to {{/exclusiveMaximum}}{{maximum}}.')];
        }
        {{/maximum}}
        {{#minimum}}
        if ({{^required}}!is_null(${{name}}) && {{/required}}(${{name}} <{{#exclusiveMinimum}}={{/exclusiveMinimum}} {{minimum}})) {
            return [new ValidationError('invalid value for ${{name}} when calling {{classname}}.{{operationId}}, must be bigger than {{^exclusiveMinimum}}or equal to {{/exclusiveMinimum}}{{minimum}}.')];
        }
        {{/minimum}}
        {{#pattern}}
        if ({{^required}}!is_null(${{name}}) && {{/required}}(!preg_match("{{{pattern}}}", ${{name}}))) {
            return [new ValidationError("invalid value for ${{name}} when calling {{classname}}.{{operationId}}, must conform to the pattern {{{pattern}}}.")];
        }
        {{/pattern}}
        {{#maxItems}}
        if ({{^required}}!is_null(${{name}}) && {{/required}}(count(${{name}}) > {{maxItems}})) {
            return [new ValidationError('invalid value for ${{name}} when calling {{classname}}.{{operationId}}, number of items must be less than or equal to {{maxItems}}.')];
        }{{/maxItems}}
        {{#minItems}}
        if ({{^required}}!is_null(${{name}}) && {{/required}}(count(${{name}}) < {{minItems}})) {
            return [new ValidationError('invalid length for ${{name}} when calling {{classname}}.{{operationId}}, number of items must be greater than or equal to {{minItems}}.')];
        }
        {{/minItems}}
        {{/hasValidation}}
        return [];
    }
    {{/vars}}
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }
}
